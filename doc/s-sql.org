#+TITLE: S-SQL Reference Manual
#+OPTIONS: num:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
#+OPTIONS: ^:nil

This is the reference manual for the S-SQL component of the postmodern library.

S-SQL provides a lispy syntax for SQL queries, and knows how to convert various
lisp types to their textual SQL representation. It takes care to do as much of
the work as possible at compile-time, so that at runtime a string concatenation
is all that is needed to produce the final SQL query.


* Interface
  :PROPERTIES:
  :ID:       462ce6d8-f967-4bce-817e-d1762ebfd41f
  :END:
#+NAME: SQL
** macro sql (form)
   :PROPERTIES:
   :ID:       9de76637-62f7-4c7c-a5d1-1f37491b3db3
   :END:
→ string

Convert the given form (a list starting with a keyword) to an SQL query string
at compile time, according to the rules described here. For example:
#+BEGIN_SRC lisp
(sql (:select '* :from 'country :where (:= 'a 1)))

 "(SELECT * FROM country WHERE (a = 1))"
#+END_SRC

but
#+BEGIN_SRC lisp
(sql '(:select '* :from 'country :where (:= 'a 1)))
#+END_SRC

would throw an error. For the later case you need to use sql-compile.

** function sql-compile (form)
   :PROPERTIES:
   :ID:       8d161d2a-06cb-4334-9ee6-86e805eb5295
   :END:
→ string

This is the run-time variant of the sql macro. It converts the given list to
an SQL query, with the same rules except that symbols in this list do not
have to be quoted to be interpreted as identifiers. For example:
#+BEGIN_SRC lisp
(sql-compile '(:select '* :from 'country :where (:= 'a 1)))

\"(SELECT * FROM country WHERE (a = 1))\"
#+END_SRC

but
#+BEGIN_SRC lisp
(sql (:select '* :from 'country :where (:= 'a 1)))
#+END_SRC

would throw an error. For the later case you need to use sql.

** function sql-template (form)
   :PROPERTIES:
   :ID:       e16e8407-01af-4907-9ed6-2b3c1f12dd1b
   :END:

In cases where you do need to build the query at run time, yet you do not
want to re-compile it all the time, this function can be used to compile it
once and store the result. It takes an S-SQL form, which may contain
$$ placeholder symbols, and returns a function that takes one argument for
every $$. When called, this returned function produces an SQL string in
which the placeholders have been replaced by the values of the arguments.

** function enable-s-sql-syntax (&optional (char #\Q))
   :PROPERTIES:
   :ID:       bee65d01-61d4-4823-b0ab-26789642cdb3
   :END:

Modifies the current readtable to add a #Q syntax that is read as (sql ...).
The character to use can be overridden by passing an argument.

#+NAME: sql escape string
** function sql-escape-string (string)
   :PROPERTIES:
   :ID:       02edac61-f915-4d5f-b52e-d4b7ace29352
   :END:
→ string

[[http://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS][Escapes]] a string for inclusion in a PostgreSQL query. Example:
#+BEGIN_SRC lisp
 (sql-escape-string \"Puss in 'Boots'\")

 \"E'Puss in ''Boots'''\"

#+END_SRC

** method sql-escape (value)
   :PROPERTIES:
   :ID:       59d7247c-c2fa-46c3-b682-dab17fac8812
   :END:
→ string

A generalisation of sql-escape-string looks at the type of the value passed, and properly writes it out it for inclusion in an SQL query. Symbols will be
converted to SQL names. Examples:
#+BEGIN_SRC lisp
(sql-escape "tr'-x")

"E'tr''-x'"

(sql-escape (/ 1 13))

"0.0769230769230769230769230769230769230"

(sql-escape #("Baden-Wurttemberg" "Bavaria" "Berlin" "Brandenburg"))

"ARRAY[E'Baden-Wurttemberg', E'Bavaria', E'Berlin', E'Brandenburg']"
#+END_SRC
** variable *downcase-symbols*
   :PROPERTIES:
   :ID:       19c05bac-8209-4e48-b2e0-549ff03df44e
   :END:

When converting symbols to strings, whether to downcase the symbols is set here. The default is to downcase symbols.
** variable *standard-sql-strings*
   :PROPERTIES:
   :ID:       95a70c76-0fcb-4967-88a2-3460bbcb5311
   :END:

Used to configure whether S-SQL will use standard SQL strings (just replace #\' with ''), or backslash-style escaping. Setting this to NIL is always safe, but when the server is configured to allow standard strings (compile-time parameter 'standard_conforming_strings' is 'on', which will become the default in future versions of PostgreSQL), the noise in queries can be reduced by setting this to T.

** variable *postgres-reserved-words* hashtable
   :PROPERTIES:
   :ID:       a975b46b-5ade-4358-aa77-f83681299a94
   :END:

A set of all Postgresql's reserved words, for automatic escaping. Probably not a good idea to use these words as identifiers anyway.
 '("all" "analyse" "analyze" "and" "any" "array" "as" "asc" "asymmetric" "authorization"
   "between" "binary" "both" "case" "cast" "check" "collate" "column" "concurrently"
   "constraint" "create" "cross" "current-catalog" "current-date" "current-role" "current-schema"
   "current-time" "current-timestamp" "current-user" "default" "deferrable"
   "desc" "distinct" "do" "else" "end" "except" "false" "fetch" "filter"
   "for" "foreign" "freeze" "from" "full" "grant" "group" "having" "ilike" "in" "initially"
   "inner" "intersect" "into" "is" "isnull" "join" "lateral" "leading" "left" "like" "limit"
   "localtime" "localtimestamp" "natural" "new" "not" "notnull" "nowait" "null" "off" "offset" "old"
   "on" "only" "or" "order" "outer" "overlaps" "placing" "primary" "references" "returning"
   "right" "select" "session-user" "Share" "similar" "some" "symmetric" "table" "then" "to" "trailing" "true"
   "union" "unique" "user" "using" "variadic" "verbose" "when" "where" "window" "with"))

** variable *escape-sql-names-p*
   :PROPERTIES:
   :ID:       974ac94c-23eb-4bba-b324-d79fba034c1d
   :END:

Determines whether double quotes are added around column, table, and ** function names in
queries. Valid values:

- T, in which case every name is escaped,
- NIL, in which case no name is escape,
- :auto, which causes only [[http://www.postgresql.org/docs/current/static/sql-keywords-appendix.html][reserved words]] to be escaped, or.
- :literal which is the same as :auto except it has added consequence in to-sql-name (see below).

The default value is :auto.

Be careful when binding this with let and such ― since a lot of SQL compilation tends to happen at
compile-time, the result might not be what you expect. Mixed case sensitivity is not currently
well supported. Postgresql itself will downcase unquoted identifiers. This will be revisited in the
future if requested.

** function sql-type-name (type)
   :PROPERTIES:
   :ID:       79bc7903-3321-4e01-a0a0-819ad61179b5
   :END:
→ string

Transform a lisp type into a string containing something SQL understands. Default is to just use the type symbol's name.

** function to-sql-name (name &optional (escape-p *escape-sql-names-p*)(ignore-reserved-words nil)
   :PROPERTIES:
   :ID:       46c8eab0-4fac-4b14-8193-6b93c985ad0f
   :END:
→ string

Convert a symbol or string into a name that can be a sql table, column, or operation name. Add quotes when escape-p is true, or escape-p is :auto and the name contains reserved words. Quoted or delimited identifiers can be used by passing :literal as the value of escape-p. If escape-p is :literal, and the name is a string then the string is still escaped but the symbol or string is not downcased, regardless of the setting for *downcase-symbols* and the hyphen and forward slash characters are not replaced with underscores.

Ignore-reserved-words is only used internally for column names which are allowed to be reserved words, but it is not recommended.


** function from-sql-name (string)
   :PROPERTIES:
   :ID:       5a8737c8-f850-4807-974c-8f711cc9ae1c
   :END:
→ keyword

Convert a string that represents an SQL identifier to a keyword by uppercasing
it and converting the underscores to dashes.

** macro register-sql-operators (arity &rest names)
   :PROPERTIES:
   :ID:       594e6029-8c94-4bb6-ad36-83ab42dc6369
   :END:

Define simple SQL operators. Arity is one of :unary (like 'not'), :unary-postfix
(the operator comes after the operand), :n-ary (like '\+': the operator falls away
when there is only one operand), :2+-ary (like '=', which is meaningless for one
operand), or :n-or-unary (like '-', where the operator is kept in the unary case).
After the arity may follow any number of operators, either just a keyword, in
which case the downcased symbol name is used as the SQL operator, or a two-element
list containing a keyword and a name string.

#+NAME: SQL Types
* SQL Types
  :PROPERTIES:
  :ID:       fd140802-2b42-49b6-b21c-c0d4adae6136
  :END:
S-SQL knows the SQL equivalents to a number of Lisp types, and defines some
extra types that can be used to denote other SQL types. The following
table shows the correspondence:

| Lisp type           | SQL type         | Description                                                                       |
|---------------------+------------------+-----------------------------------------------------------------------------------|
| integer             | smallint         | -32,768 to +32,768 2-byte storage                                                 |
| integer             | integer          | -2147483648 to +2147483647 integer, 4-byte storage                                |
| integer             | bigint           | -9223372036854775808 to 9223372036854775807 integer 8-byte storage                |
| (numeric X Y)       | numeric(X, Y)    |                                                                                   |
| float, real         | real             | single-precision floating point number, 6 decimal digit precision 4-byte storage  |
| double-float        | double-precision | double-precision floating point number, 15 decimal digit precision 8-byte storage |
| string, text        | text             | variable length string, no limit specified                                        |
| string              | char(X)          | char(length), blank-padded string, fixed storage length                           |
| string              | varchar(X)       | varchar(length), non-blank-padded string, variable storage length                 |
| boolean             | boolean          | boolean, 'true'/'false', 1 byte                                                   |
| bytea               | bytea            |                                                                                   |
| date                | date             | date range: 4713 BC to 5874897 AD                                                 |
| [[file:interval-notes.html][interval]]            | interval         |                                                                                   |
| array               | array            |                                                                                   |

** type db-null
   :PROPERTIES:
   :ID:       73bdde0f-96d9-494e-854e-f03f6197c88f
   :END:

This is a type of which only the keyword :null is a member. It is used to represent
NULL values from the database.

* SQL Syntax
  :PROPERTIES:
  :ID:       13fef0a2-bbe1-44a1-9bc1-570ffdbb4093
  :END:
An S-SQL form is converted to a query through the following rules:

- Lists starting with a keyword are operators. They are expanded as
  described below if they are known, otherwise they are expanded in the
  standard way: operator(arguments, ...)

- Quoted symbols or keywords are interpreted as names of columns or
  tables, and converted to strings with to-sql-name.

- Anything else is evaluated and the resulting Lisp value is converted
  to its textual SQL representation (or an error is raised when there is
  no rule for converting objects of this type). Self-quoting atoms may
  be converted to strings at compile-time.

** sql-op :select (&rest args)
   :PROPERTIES:
   :ID:       e8ff770d-fbce-461d-ac3b-4959bc8770c1
   :END:

Creates a select query. The arguments are split on the keywords found among
them. The group of arguments immediately after :select is interpreted as
the expressions that should be selected. After this, an optional :distinct
may follow, which will cause the query to only select distinct rows, or
alternatively :distinct-on followed by a group of row names. Next comes the
optional keyword :from, followed by at least one table name and then any
number of join statements. Join statements start with one of :left-join,
:right-join, :inner-join, :outer-join or :cross-join, then a table name or
subquery, then the keyword :on or :using, if applicable, and then a form.
A join can be preceded by :natural (leaving off the :on clause) to use a
natural join. After the joins an optional :where followed by a single form
may occur. And finally :group-by and :having can optionally be specified.
The first takes any number of arguments, and the second only one. An example:
#+BEGIN_SRC lisp
(query (:select (:+ 'field-1 100) 'field-5
        :from (:as 'my-table 'x)
        :left-join 'your-table
        :on (:= 'x.field-2 'your-table.field-1)
        :where (:not-null 'a.field-3)))
#+END_SRC

The following operators are defined:

** sql-op :+, :*, :%, :&, :|, :||, :and, :or, :=, :/, :!=, :<, :>, :<=, :>=, :^, :union, :union-all, :intersect, :intersect-all, :except, :except-all (&rest args)
   :PROPERTIES:
   :ID:       405ec72e-7b79-4d96-aa32-1a3f931dd5a4
   :END:

These are expanded as infix operators. When meaningful, they allow more than
two arguments. :- can also be used as a unary operator to negate a value.
Note that the arguments to :union, :union-all, :intersect, and :except
should be queries (:select forms).

Note that you'll have to escape pipe characters to enter them as keywords. S-SQL
handles the empty keyword symbol (written :||) specially, and treats it like :\|\|,
so that it can be written without escapes. With :\|, this doesn't work.

** sql-op :~, :not (arg)
   :PROPERTIES:
   :ID:       1604e97e-40e9-4fca-bf0a-897850766386
   :END:

Unary operators for bitwise and logical negation.

** sql-op :function (name (&rest arg-types) return-type stability body)
   :PROPERTIES:
   :ID:       55203563-3759-427f-8147-2396c642144d
   :END:

Create a stored procedure. The argument and return types are interpreted as
type names and not evaluated. Stability should be one of :immutable, :stable,
or :volatile (see the PostgreSQL documentation). For example, a function that
gets foobars by id:
#+BEGIN_SRC lisp
(:function 'get-foobar (integer) foobar :stable (:select '* :from 'foobar :where (:= 'id '$1)))
#+END_SRC

** sql-op :~, :~*, :!~, :!~* (string pattern)
   :PROPERTIES:
   :ID:       228320ed-6925-4a55-92c8-b48066f7e02c
   :END:

Regular expression matching operators. The exclamation mark means 'does not match',
the asterisk makes the match case-insensitive.

** sql-op :like, :ilike (string pattern)
   :PROPERTIES:
   :ID:       89ce2b9e-50d8-4376-99e5-b085639f2cae
   :END:

Simple SQL string matching operators (:ilike is case-insensitive).

** sql-op :@@
   :PROPERTIES:
   :ID:       7e33f04a-09f8-4177-bf8b-ae6f42eb33cc
   :END:

Fast Text Search match operator.

** sql-op :desc (column)
   :PROPERTIES:
   :ID:       bfa41b7a-e1be-42be-b1b7-ecaa0913391c
   :END:

Used to invert the meaning of an operator in an :order-by clause.

** sql-op :nulls-first, :nulls-last (column)
   :PROPERTIES:
   :ID:       53293652-8d98-40fb-b629-7f3350a1b16c
   :END:

Used to determine where :null values appear in an :order-by clause.

** sql-op :as (form name &rest fields)
   :PROPERTIES:
   :ID:       ca6fe6aa-07ad-4931-afe5-9d9087059dca
   :END:

Assigns a name to a column or table in a :select form. When fields are given,
they are added after the name, in parentheses. For example, (:as 'table1 't1 'foo 'bar)
becomes table1 AS t1(foo, bar). When you need to specify types for the fields,
you can do something like (:as 'table2 't2 ('foo integer)). Note that names are
quoted, types are not (when using sql-compile or sql-template, you can leave
out the quotes entirely).

** sql-op :cast (query)
   :PROPERTIES:
   :ID:       fdab4fe0-46bb-4240-b629-773c21b8d304
   :END:

The CAST operator. Takes a query as an argument, and returns the result
explicitly cast by postgresql to a specific type.
#+BEGIN_SRC lisp
(query (:select (:cast (:as "20" 'integer)))
        :single)
20

(query (:union (:select (:as 1 'real))
               (:select (:cast (:as "2.2" 'real)))))
((1.0) (2.2))
#+END_SRC
** sql-op :type (query)
   :PROPERTIES:
   :ID:       249f05e6-b7c7-4b53-a215-73673f9aa2b0
   :END:
Is similar to cast but uses the postgresql :: formating. E.g.
#+BEGIN_SRC lisp
(sql (:select (:as (:- (:type (:now) date) 'x) 'some-date) :from (:as (:generate-series 1 10) 'x)))

"(SELECT (now()::DATE - x) AS some_date FROM generate_series(1, 10) AS x)"
#+END_SRC
** sql-op :create-composite-type (type-name &rest args)
   :PROPERTIES:
   :ID:       6fdeb899-f180-47f7-b8e1-6ad314c7952b
   :END:
Creates a composite type with a type-name and two or more columns. E.g.
#+BEGIN_SRC lisp
(query (:create-composite-type 'fullname (first-name text) (last-name text)))
#+END_SRC
** sql-op :exists (query)
   :PROPERTIES:
   :ID:       edab7fef-c6c1-4875-8b41-54bf05242554
   :END:

The EXISTS operator. Takes a query as an argument, and returns true or false
depending on whether that query returns any rows.

** sql-op :is-null (arg)
   :PROPERTIES:
   :ID:       48e3d777-1fde-4e60-b8d2-d8f7b8fea7bf
   :END:

Test whether a value is null.

** sql-op :not-null (arg)
   :PROPERTIES:
   :ID:       74c212eb-330e-459a-bdc4-2d2e75046972
   :END:
Test whether a value is not null.
** sql-op :in (value set)
   :PROPERTIES:
   :ID:       45c17b50-7b34-42d9-8dd2-08ccd12fa7c0
   :END:

Test whether a value is in a set of values.

** sql-op :not-in (value set)
   :PROPERTIES:
   :ID:       f8f9f42f-00b7-4b17-b2fb-2ef90dd8ec2c
   :END:

Inverse of the above.

** sql-op :set (&rest elements)
   :PROPERTIES:
   :ID:       72eea20e-6e5f-4a9a-ba2f-f5f23327b397
   :END:

Denote a set of values. This operator has two interfaces. When
the elements are known at compile-time, they can be given as
multiple arguments to the operator. When they are not, a
single argument that evaluates to a list should be used.

** sql-op :array (query)
   :PROPERTIES:
   :ID:       f7a7e6fb-00f9-407b-b929-78f17e164052
   :END:

This is used when calling a select query into an array.  See [[file:array-notes.html][array-notes.html]]
for more detailed notes on the use of arrays.
#+BEGIN_SRC lisp
(query (:order-by
        (:select 'r.rolename
                 (:as (:array
                       (:select 'b.rolename
                                :from (:as 'pg_catalog.pg-auth-members 'm)
                                :inner-join (:as 'pg-catalog.pg-roles 'b)
                                :on (:= 'm.roleid 'b.oid)
                                :where (:= 'm.member 'r.oid )))
                      'memberof)

                 :from (:as 'pg-catalog.pg-roles 'r))
        1))

#+END_SRC

** sql-op :array[] (&rest args)
   :PROPERTIES:
   :ID:       1b9af15e-051a-401f-a251-1a7173685c9e
   :END:

This is the general operator for arrays. It also handles statements that include
functions in the query such as (:+ 1 2), (:pi) in the array. See [[file:array-notes.html][array-notes.html]]
for more detailed notes on the use of arrays.
#+BEGIN_SRC lisp
(query (:select (:array-prepend 1 (:array[] 2 3))))

((#(1 2 3)))

(query (:select (:array-prepend 1 (:array[] 2 3)))
       :single)

#(1 2 3)
#+END_SRC

** sql-op :[] (form start &optional end)
   :PROPERTIES:
   :ID:       7afc83f1-4054-4a6c-8ea2-99549e037998
   :END:

Dereference an array value. If end is provided, extract a slice of the array.
Sample usage below, but also see [[file:array-notes.html][array-notes.html]] for more detailed notes on
the use of arrays.
#+BEGIN_SRC lisp
(query (:select 'receipe-id (:[] 'tags 2 3)
                :from 'receipe-tags-array
                :where (:= 'receipe-id 3)))
#+END_SRC

** sql-op :extract (unit form)
   :PROPERTIES:
   :ID:       2ed4ee9b-b199-43df-9b4b-f33d67629793
   :END:

Extract a field from a date/time value. For example, (:extract :month (:now)).

** sql-op :case (&rest clauses)
   :PROPERTIES:
   :ID:       95c998be-86a0-4553-ba2d-b1afa04205d6
   :END:

A conditional expression. Clauses should take the form (test value). If
test is :else, an ELSE clause will be generated.

** sql-op :between (n start end)
   :PROPERTIES:
   :ID:       3eb62a27-e798-47c9-99a3-34efb86b0a6e
   :END:

Test whether a value lies between two other values.

** sql-op :between-symmetric (n start end)
   :PROPERTIES:
   :ID:       7acf3e85-924c-42cb-84ec-4ab0430f6fc0
   :END:

Works like :between, except that the start value is not required to be
less than the end value.

** sql-op :dot (&rest names)
   :PROPERTIES:
   :ID:       5d7287f0-9527-46da-8bc7-8220b49b53a2
   :END:

Can be used to combine multiple names into a name of the form A.B to
refer to a column in a table, or a table in a schema. Note that you
can also just use a symbol with a dot in it.

** sql-op :type (form type)
   :PROPERTIES:
   :ID:       ccedb33a-7e65-4a25-9e0a-a5611665c9a8
   :END:

Add a type declaration to a value, as in in "4.3::real". The second
argument is not evaluated normally, but put through sql-type-name to
get a type identifier.

** sql-op :raw (string)
   :PROPERTIES:
   :ID:       4833bb9a-223b-4d29-a9ca-8e243abb1fab
   :END:

Insert a string as-is into the query. This can be useful for doing things
that the syntax does not support, or to re-use parts of a query across
multiple queries:
#+BEGIN_SRC lisp
(let* ((test (sql (:and (:= 'foo 22) (:not-null 'bar))))
       (rows (query (:select '* :from 'baz :where (:raw test)))))
  (query (:delete-from 'baz :where (:raw test)))
  (do-stuff rows))
#+END_SRC

** sql-op :limit (query amount &optional offset)
   :PROPERTIES:
   :ID:       1b0cc29f-7b0a-4bca-8f79-5e763fc9a356
   :END:

In S-SQL limit is not part of the select operator, but an extra
operator that is applied to a query (this works out better when limiting
the union or intersection of multiple queries, same for sorting).
It limits the number of results to the amount given as the second
argument, and optionally offsets the result by the amount given
as the third argument.

** sql-op :order-by (query &rest exprs)
   :PROPERTIES:
   :ID:       df5b679e-5f4b-4599-b533-82c3e9d4f13b
   :END:

Order the results of a query by the given expressions. See :desc for
when you want to invert an ordering. Note: This is not the same as
passing an :order-by parameter to an aggregation operator.
See Aggregation Operators.

** sql-op :values
   :PROPERTIES:
   :ID:       d7cc1523-6341-4d80-a08a-c76898a99501
   :END:

Values computes a row value or set of row values for use in a specific
query. See the postgresql docs at:
https://www.postgresql.org/docs/current/static/queries-values.html
and https://www.postgresql.org/docs/current/static/sql-values.html
Example:
#+BEGIN_SRC lisp
(query (:select '*
                :from (:as (:values (:set 1 "one")
                                    (:set 2 "two")
                                    (:set 3 "three"))
                           (:t1 'num 'letter))))

(query (:select 'a 'b 'c (:cast (:as (:* 50 (:random)) 'int))
                :from (:as (:values (:set "a") (:set "b")) (:d1 'a))
                (:as (:values (:set "c") (:set "d")) (:d2 'b))
                (:as (:values (:set "e") (:set "f")) (:d3 'c))))

(query
 (:with-recursive
  (:as (:t1 'n)
       (:union-all (:values (:set 1))
                   (:select (:+ 'n 1)
                            :from 't1
                            :where (:< 'n 100))))
  (:select (:sum 'n) :from 't1))
 :single)
#+END_SRC

** sql-op :empty-set
   :PROPERTIES:
   :ID:       a7daaf56-9824-4a6f-8ada-313221e034cb
   :END:

This is a fudge. It returns a string "()" where something like '()
would return "false" or :() would throw an error. Example:
#+BEGIN_SRC lisp
(query (:select 'appnumber 'day (:sum 'inserts)
                (:sum 'updates) (:sum 'deletes) (:sum 'transactions)
                :from 'db-details
                :group-by (:grouping-sets (:set 'appnumber 'day (:empty-set)))))
#+END_SRC

** sql-op :group-by
   :PROPERTIES:
   :ID:       8f5b4a28-a801-424d-9ff6-4460fa7f048d
   :END:

https://www.postgresql.org/docs/current/static/queries-table-expressions.html#QUERIES-GROUPING-SETS
The GROUP BY Clause is used to group together those rows in a table that
have the same values in all the columns listed. The order in which the
columns are listed does not matter. The effect is to combine each set of
rows having common values into one group row that represents all rows in
the group. This is done to eliminate redundancy in the output and/or compute
aggregates that apply to these groups. Example:
#+BEGIN_SRC lisp
(query (:order-by
        (:select 'mems.surname 'mems.firstname 'mems.memid (:as (:min 'bks.starttime) 'starttime)
                 :from (:as 'cd.bookings 'bks)
                 :inner-join (:as 'cd.members 'mems)
                 :on (:= 'mems.memid 'bks.memid)
                 :where (:>= 'starttime "2012-09-01")
                 :group-by 'mems.surname 'mems.firstname 'mems.memid)
        'mems.memid))
#+END_SRC

** sql-op :grouping-sets
   :PROPERTIES:
   :ID:       dfcde273-6c53-488a-b8d2-43adc3a95d23
   :END:

https://www.postgresql.org/docs/current/static/queries-table-expressions.html#QUERIES-GROUPING-SETS
More complex grouping operations are possible using the concept of grouping
sets. The data selected by the FROM and WHERE clauses is grouped separately
by each specified grouping set, aggregates computed for each group just as
for simple GROUP BY clauses, and then the results returned.
This operator requires postgresql 9.5 or later. For example:
#+BEGIN_SRC lisp
(query (:select 'city (:as (:extract 'year 'start-date)  'joining-year) (:as (:count 1) 'employee_count)
                :from 'employee
                :group-by (:grouping-sets (:set 'city (:extract 'year 'start-date)))))
#+END_SRC

* Time, Date and Interval Operators
  :PROPERTIES:
  :ID:       d07d0cf2-6766-4b7a-af0b-57a0c2b754eb
  :END:
** sql-op :interval (arg)
   :PROPERTIES:
   :ID:       330de3f2-1869-47a2-8a0d-467a38e3254f
   :END:
Creates an interval data type, generally represented in postmodern as an alist
** sql-op :current-date ()
   :PROPERTIES:
   :ID:       6d1cf4f1-89f8-4586-9e19-58c6003e5166
   :END:
#+BEGIN_SRC lisp
(query (:select (:current-date)) :single)
#+END_SRC
** sql-op :current-time ()
   :PROPERTIES:
   :ID:       2f80fe21-7abe-4eed-aa57-1b8a11cddfd1
   :END:
** sql-op :current-timestamp ()
   :PROPERTIES:
   :ID:       5c124bd3-f248-45dd-9965-51c368cd3225
   :END:
** sql-op :timestamp (arg)
   :PROPERTIES:
   :ID:       1969c373-6093-46dc-9f41-001190399cbd
   :END:
** sql-op :age (&rest args)
   :PROPERTIES:
   :ID:       e4872980-3b59-4cd5-844b-ce8912160010
   :END:
** sql-op :date (arg)
   :PROPERTIES:
   :ID:       e155b65b-05d2-4583-a185-419817382e37
   :END:
** sql-op :make-interval (&rest args)
   :PROPERTIES:
   :ID:       2794d9dd-9ab6-4d4b-8b9f-49056d214b67
   :END:
Takes lists of (time-unit value) and returns a timestamp type. Example:

#+BEGIN_SRC lisp
(query (:select (:make-interval ("days" 4) ("hours" 10) ("secs" 1.2)))
       :single)
#+END_SRC
** sql-op :make-timestamp (&rest args)
   :PROPERTIES:
   :ID:       f4e7bf1a-25b1-4c2b-8794-9550164a0ee1
   :END:
Takes lists of (time-unit value) and returns a timestamptz type. Example:
#+BEGIN_SRC lisp
(query (:select
          (:make-timestamptz ("year" 2014) ("month" 1) ("mday" 13)
                             ("hour" 21) ("min" 50) ("sec" 0)))
       :single)
#+END_SRC
** sql-op :make-timestamptz (&rest args)
   :PROPERTIES:
   :ID:       b6f82034-e002-4dd2-9bde-ae025176cb9a
   :END:
Takes lists of (time-unit value) and returns a timestamptz type. Example:
#+BEGIN_SRC lisp
(query (:select
          (:make-timestamptz ("year" 2014) ("month" 1) ("mday" 13)
                             ("hour" 21) ("min" 50) ("sec" 0) ("timezone" "Asia/Tokyo")))
       :single)
#+END_SRC

* Aggregation Operators
  :PROPERTIES:
  :ID:       cd2bdccf-0de5-4b57-a195-0c94029e8c8e
  :END:
** sql-op :count (&rest args)
   :PROPERTIES:
   :ID:       40eed2a4-b3f5-4380-a3b7-16a5bdcbe0b3
   :END:

Count returns the number of rows for which the expression is not null.
It can be the number of rows collected by the select statement as in:
#+BEGIN_SRC lisp
(query (:select (:count '*)
                :from 'table1
                :where (:= 'price 100)))
#+END_SRC

or it can be a smaller number of rows based on the allowed keyword
parameters :distinct and :filter or some other type of condition as in:
#+BEGIN_SRC lisp
(query (:select (:count 'memid :distinct)
                :from 'cd.bookings))
#+END_SRC
or

#+BEGIN_SRC lisp
(query (:select (:as (:count '* :distinct) 'unfiltered)
                (:as (:count '* :filter (:= 1 'bid))
                     'filtered)
                :from 'testtable))
#+END_SRC

Note that if used, the filter must be last in the count args. If distinct
is used, it must come before filter. Unlike standard sql, the word 'where'
is not used inside the filter clause. E.g.
#+BEGIN_SRC lisp
(query (:select (:count '*)
                (:count '* :filter (:= 1 'bid))
                'id
                :from 'pbbench-history))
#+END_SRC

See tests.lisp for examples.

** sql-op :avg (&rest rest args)
   :PROPERTIES:
   :ID:       0e6463d4-d83c-493b-8989-4819c6e9f914
   :END:

Avg calculates the average value of a list of values. Note that if the
filter keyword is used, the filter must be last in the avg args. If distinct
is used, it must come before filter. E.g. See tests.lisp for more examples.
#+BEGIN_SRC lisp
(query (:select (:avg '*) (:avg '* :filter (:= 1 'bid)) 'id
                :from 'pbbench-history))
#+END_SRC

** sql-op :sum (&rest rest args)
   :PROPERTIES:
   :ID:       d8379b94-922b-47d3-9161-5da838b43f42
   :END:

Sum calculates the total of a list of values. Note that if the keyword filter
is used, the filter must be last in the sum args. If distinct is used, it
must come before filter. Unlike standard sql, the word 'where' is not used
inside the filter clause (s-sql will properly expand it). See tests.lisp
for more examples.
#+BEGIN_SRC lisp
(query (:select (:sum '*) (:sum '* :filter (:= 1 'bid)) 'id
                :from 'pbbench-history))
#+END_SRC

** sql-op ::max (&rest args)
   :PROPERTIES:
   :ID:       66db79ad-e7d4-43dd-a6af-fe3085c16d12
   :END:

max returns the maximum value of a set of values. Note that if the filter
keyword is used, the filter must be last in the max args. If distinct is
used, it must come before filter. Unlike standard sql, the word 'where'
is not used inside the filter clause (s-sql will properly expand it).
See tests.lisp for more examples.

#+BEGIN_SRC lisp
(query (:select (:max '*) (:max '* :filter (:= 1 'bid)) 'id
                :from 'pbbench-history))
#+END_SRC
** sql-op ::min (&rest args)
   :PROPERTIES:
   :ID:       02c03a2a-114d-4b4b-8214-12411c979a0f
   :END:

min returns the minimum value of a set of values. Note that if the filter
keyword is used, the filter must be last in the min args. If distinct is
used, it must come before filter. Unlike standard sql, the word 'where'
is not used inside the filter clause (s-sql will properly expand it).
See tests.lisp for more examples.
#+BEGIN_SRC lisp
(query (:select (:min '*) (:min '* :filter (:= 1 'bid)) 'id
                :from 'pbbench-history))
#+END_SRC

** sql-op ::every (&rest args)
   :PROPERTIES:
   :ID:       3683daea-ef97-4cb9-a78e-aa40fc3df983
   :END:

Every returns true if all input values are true, otherwise false. Note
that if the filter keyword is used, the filter must be last in the every
args. If distinct is used, it must come before filter. Unlike standard sql,
the word 'where' is not used inside the filter clause (s-sql will
properly expand it). See tests.lisp for more examples.
#+BEGIN_SRC lisp
(query (:select '* (:every (:like 'studname "%h"))
                :from 'tbl-students
                :group-by 'studname 'studid 'studgrades))
#+END_SRC

** sql-op :percentile-cont (&rest args)
   :PROPERTIES:
   :ID:       3a6ee0b8-64cd-4937-b769-95f3ec44c32a
   :END:

Requires Postgresql 9.4 or higher. Percentile-cont returns a value
corresponding to the specified fraction in the ordering, interpolating
between adjacent input items if needed. There are two required keyword
parameters :fraction and :order-by. If the fraction value is an array,
then it returns an array of results matching the shape of the fractions
parameter, with each non-null element replaced by the value corresponding
to that percentile. Examples:
#+BEGIN_SRC lisp
(query (:select (:percentile-cont :fraction 0.5 :order-by 'number-of-staff)
                :from 'schools))

(query (:select (:percentile-cont :fraction array[0.25 0.5 0.75 1]
                                  :order-by 'number-of-staff)
                :from  'schools))
#+END_SRC


** sql-op :percentile-dist (&rest args)
   :PROPERTIES:
   :ID:       5f53ac18-189b-4df7-99ac-02ebbd8a9606
   :END:

Requires Postgresql 9.4 or higher. There are two required keyword parameters
:fraction and :order-by. Percentile-dist returns the first input value whose
position in the ordering equals or exceeds the specified fraction. If the
fraction parameter is an array eturns an array of results matching the shape
of the fractions parameter, with each non-null element replaced by the input
value corresponding to that percentile. Examples:

#+BEGIN_SRC lisp
(query (:select (:percentile-dist :fraction 0.5
                                  :order-by 'number-of-staff)
                :from 'schools))

(query (:select (:percentile-dist :fraction array[0.25 0.5 0.75 1]
                                  :order-by 'number-of-staff)
                :from  'schools))

#+END_SRC

** sql-op :corr (y x)
   :PROPERTIES:
   :ID:       36db9511-5ba0-4dfc-9646-71b2d47857b0
   :END:

The corr function returns the correlation coefficient between a set of
dependent and independent variables. Example:
#+BEGIN_SRC lisp
(query (:select (:corr 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :covar-pop (y x)
   :PROPERTIES:
   :ID:       e6b20c69-d328-4a59-b030-9c03c9201305
   :END:

The covar-pop function returns the population covariance between a set of
dependent and independent variables. Example:
#+BEGIN_SRC lisp
(query (:select (:covar-pop 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :covar-samp (y x)
   :PROPERTIES:
   :ID:       9112880c-0d43-43bb-96b0-416e4f1e2bc3
   :END:
#+BEGIN_SRC lisp
(query (:select (:covar-samp 'height 'weight)
                :from 'people))
#+END_SRC
The covar-samp function returns the sample covariance between a set of
dependent and independent variables. Example:

** sql-op :string-agg (&rest args)
   :PROPERTIES:
   :ID:       cd16b4cb-51f9-4bff-ac6e-7482fc2e1ffa
   :END:

String-agg allows you to concatenate strings using different types of
delimiter symbols. Allowable optional keyword parameters are :distinct,
:order-by and :filter Note that order-by in string-agg requires
postgresql 9.0 or later. Filter requires postgresql 9.4 or later.
See tests.lisp for more examples.
#+BEGIN_SRC lisp
(query (:select (:as (:string-agg 'bp.step-type \",\" )
                     'step-summary)
                :from 'business-process))

(query (:select 'mid (:as (:string-agg  'y \",\" :distinct :order-by (:desc 'y))
                          'words)
                :from 'moves))

(query (:select (:string-agg  'name "," :order-by (:desc 'name) :filter (:< 'id 4))
                :from 'employee))
#+END_SRC

** sql-op :array-agg (&rest args)
   :PROPERTIES:
   :ID:       dbf248ce-f480-4940-93d6-837aaa22529d
   :END:

Array-agg returns a list of values concatenated into an arrays.
Allowable optional keyword parameters are :distinct, :order-by
and :filter.

Note that order-by in array-agg requires postgresql 9.0 or later.
Filter requires postgresql 9.4 or later. See [[file:array-notes.html][array-notes.html]] for more
detailed notes on the use of arrays.

Example with Filter:
#+BEGIN_SRC lisp
(query (:select 'g.id
                (:as (:array-agg 'g.users :filter (:= 'g.canonical \"Y\"))
                     'canonical-users)
                (:as (:array-agg 'g.users :filter (:= 'g.canonical \"N\"))
                     'non-canonical-users)
                :from (:as 'groups 'g)
                :group-by 'g.id))
#+END_SRC

** sql-op :mode (&rest args)
   :PROPERTIES:
   :ID:       be548451-659d-46ca-b31b-9d308b8b5cba
   :END:

Mode is used to find the most frequent input value in a group.
See e.g. https://www.postgresql.org/docs/10/static/functions-aggregate.html#FUNCTIONS-ORDEREDSET-TABLE
and article at https://tapoueh.org/blog/2017/11/the-mode-ordered-set-aggregate-function
#+BEGIN_SRC lisp
(query (:select (:mode 'items)
                :from 'item-table))
#+END_SRC

** sql-op :regr_avgx (y x)
   :PROPERTIES:
   :ID:       5c3e2dc0-d238-4116-91fd-a8111225ee94
   :END:

The regr_avgx function returns the average of the independent variable
(sum(X)/N) Example:
#+BEGIN_SRC lisp
(query (:select (:regr_avgx 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :regr_avgy (y x)
   :PROPERTIES:
   :ID:       2fc66640-03e7-4796-8209-69fba9f346a4
   :END:

The regr_avgy function returns the average of the dependent variable
(sum(Y)/N). Example:
#+BEGIN_SRC lisp

#+END_SRC
(query (:select (:regr_avgy 'height 'weight)
                :from 'people))
** sql-op :regr_count (y x)
   :PROPERTIES:
   :ID:       293a2e93-93bf-4c08-b0f4-6d3dfe0feb6b
   :END:

The regr_count function returns the number of input rows in which both
expressions are nonnull. Example:
#+BEGIN_SRC lisp
(query (:select (:regr_count 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :regr_intercept (y x)
   :PROPERTIES:
   :ID:       8b92dc89-b251-4bac-ba53-58251e98d3f5
   :END:

The regr_intercept function returns the y-intercept of the least-squares-fit
linear equation determined by the (X, Y) pairs. Example:
#+BEGIN_SRC lisp
(query (:select (:regr_intercept 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :regr_r2 (y x)
   :PROPERTIES:
   :ID:       09020f6e-166a-40e8-85ea-fdaced1f7808
   :END:

The regr_r2 function returns the square of the correlation coefficient. Example:
#+BEGIN_SRC lisp
(query (:select (:regr_r2 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :regr_slope (y x)
   :PROPERTIES:
   :ID:       b22a7906-c571-4463-884f-4067d51cf0ac
   :END:

The regr_slope function returns the slope of the least-squares-fit linear
equation determined by the (X, Y) pairs. Example:
#+BEGIN_SRC lisp
(query (:select (:regr_slope 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :regr_sxx (y x)
   :PROPERTIES:
   :ID:       9c7cc59e-419d-4161-9711-de2c9b0c27ec
   :END:

The regr_sxx function returns the sum(X^2) - sum(X)^2/N (“sum of squares” of
the independent variable). Example:
#+BEGIN_SRC lisp
(query (:select (:regr_sxx 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :regr_sxy (y x)
   :PROPERTIES:
   :ID:       24f03953-7fea-4b18-8d69-ccd5b6d9f1f5
   :END:

The regr_sxy function returns the sum(X*Y) - sum(X) * sum(Y)/N (“sum of products”
of independent times dependent variable). Example:
#+BEGIN_SRC lisp
(query (:select (:regr_sxy 'height 'weight)
                :from 'people))
#+END_SRC

** sql-op :regr_syy (y x)
   :PROPERTIES:
   :ID:       34f776b1-d29d-4d49-a66b-21262379510b
   :END:

The regr_syy function returns the sum(Y^2) - sum(Y)^2/N (“sum of squares”
of the dependent variable). Example:
#+BEGIN_SRC lisp
(query (:select (:regr_syy 'salary 'age)
                :from 'employee))
#+END_SRC

** sql-op :stddev (&rest args)
   :PROPERTIES:
   :ID:       e0558145-d8e0-4ea3-b9ae-cc92ef332b70
   :END:

The stddev function returns the the sample standard deviation of the input
values. It is a historical alias for stddev-samp. Example:
#+BEGIN_SRC lisp
(query (:select (:stddev 'salary)
                :from 'employee))
#+END_SRC

** sql-op :stddev-pop (&rest args)
   :PROPERTIES:
   :ID:       e4eeac17-7d09-45d8-8589-47d9b09a95d2
   :END:

The stddev-pop function returns the population standard deviation of the
input values. Example:
#+BEGIN_SRC lisp
(query (:select (:stddev-pop 'salary)
                :from 'employee))
#+END_SRC

** sql-op :stddev-samp (&rest args)
   :PROPERTIES:
   :ID:       4095965c-e969-4663-9ae4-2becfe72de7a
   :END:

The stddev-samp function returns the sample standard deviation of the
input values. Example:
#+BEGIN_SRC lisp
(query (:select (:stddev-samp 'salary)
                :from 'employee))
#+END_SRC

** sql-op :variance (&rest args)
   :PROPERTIES:
   :ID:       e4cd292a-4d33-434d-a698-4ae921a3173b
   :END:

Variance is a historical alias for var_samp. The variance function returns
the sample variance of the input values (square of the sample standard deviation).
Example:
#+BEGIN_SRC lisp
(query (:select (:variance 'salary)
                :from 'employee))
#+END_SRC

** sql-op :var-pop (&rest args)
   :PROPERTIES:
   :ID:       d72f79cc-b7b1-4481-a93f-6d565c6a582b
   :END:

The var-pop function returns the population variance of the input values
(square of the population standard deviation). Example:
#+BEGIN_SRC lisp
(query (:select (:var-pop 'salary)
                :from 'employee)
       :single)
#+END_SRC

** sql-op :var-samp (&rest args)
   :PROPERTIES:
   :ID:       12a5e8ba-4467-4411-a604-c8152c3fbc7d
   :END:

The var-samp function returns the sample variance of the input values
(square of the sample standard deviation). Example:
#+BEGIN_SRC lisp
(query (:select (:var-samp 'salary)
                :from 'employee)
       :single)
#+END_SRC

Window Functions
** sql-op :over (form &rest args)
   :PROPERTIES:
   :ID:       bb6eb9f2-d9ed-4348-9467-79cae9b78819
   :END:

Over, partition-by and window are so-called window functions. A window
function performs a calculation across a set of table rows that are
somehow related to the current row.
#+BEGIN_SRC lisp
(query (:select 'salary (:over (:sum 'salary))
                :from 'empsalary))
#+END_SRC

** sql-op :partition-by (&rest args)
   :PROPERTIES:
   :ID:       53d1397d-4f1d-4833-b0c1-79d18e943f8b
   :END:

Args is a list of one or more columns to partition by, optionally
followed by an :order-by clause.
#+BEGIN_SRC lisp
(query (:select 'depname 'subdepname 'empno 'salary
                (:over (:avg 'salary)
                       (:partition-by 'depname 'subdepname))
                :from 'empsalary))
#+END_SRC

Note the use of :order-by without parens:
#+BEGIN_SRC lisp
(query (:select 'depname 'empno 'salary
                (:over (:rank)
                       (:partition-by 'depname :order-by (:desc 'salary)))
                :from 'empsalary))
#+END_SRC


** sql-op :window (form)
   :PROPERTIES:
   :ID:       63d29a3b-c105-4e09-ab3b-ca5e4ece17af
   :END:
#+BEGIN_SRC lisp
(query (:select (:over (:sum 'salary) 'w)
                (:over (:avg 'salary) 'w)
                :from 'empsalary :window
                (:as 'w (:partition-by 'depname :order-by (:desc 'salary)))))
#+END_SRC

** sql-op :with (&rest args)
   :PROPERTIES:
   :ID:       38fc8a49-9a90-4f6c-930f-c704964ec991
   :END:

With provides a way to write auxillary statements for use in a larger query,
often referred to as Common Table Expressions or CTEs.
#+BEGIN_SRC lisp
(query (:with (:as 'upd
                   (:parens
                    (:update 'employees :set 'sales-count (:+ 'sales-count 1)
                             :where (:= 'id
                                        (:select 'sales-person
                                                 :from 'accounts
                                                 :where (:= 'name "Acme Corporation")))
                             :returning '*)))
              (:insert-into 'employees-log
                            (:select '* (:current-timestamp) :from
                                     'upd))))
#+END_SRC

** sql-op :with-recursive (&rest args)
   :PROPERTIES:
   :ID:       78be2433-4c26-4e2c-b333-e234393b5dc1
   :END:

Recursive modifier to a WITH statement, allowing the query to refer to its own output.
#+BEGIN_SRC lisp
(query (:with-recursive
      (:as (:t1 'n)
           (:union-all (:values (:set 1))
                       (:select (:+ 'n 1)
                                :from 't1
                                :where (:< 'n 100))))
      (:select (:sum 'n) :from 't1)))

(query (:with-recursive
      (:as (:included_parts 'sub-part 'part 'quantity)
           (:union-all
            (:select 'sub-part 'part 'quantity
                     :from 'parts
                     :where (:= 'part "our-product"))
            (:select 'p.sub-part 'p.part 'p.quantity
                     :from (:as 'included-parts 'pr)
                     (:as 'parts 'p)
                     :where (:= 'p.part 'pr.sub-part) )))
      (:select 'sub-part (:as (:sum 'quantity) 'total-quantity)
               :from 'included-parts
               :group-by 'sub-part)))

(query (:with-recursive
      (:as (:search-graph 'id 'link 'data 'depth)
           (:union-all (:select 'g.id 'g.link 'g.data 1
                                :from (:as 'graph 'g))
                       (:select 'g.id 'g.link 'g.data (:+ 'sg.depth 1)
                                :from (:as 'graph 'g) (:as 'search-graph 'sg)
                                :where (:= 'g.id 'sg.link))))
      (:select '* :from 'search-graph)))

(query (:with-recursive
      (:as (:search-graph 'id 'link 'data'depth 'path 'cycle)
           (:union-all
            (:select 'g.id 'g.link 'g.data 1
                     (:[] 'g.f1 'g.f2) nil
                     :from (:as 'graph 'g))
            (:select 'g.id 'g.link 'g.data (:+ 'sg.depth 1)
                     (:|| 'path (:row 'g.f1 'g.f2))
                     (:= (:row 'g.f1 'g.f2)
                         (:any* 'path))
                     :from (:as 'graph 'g)
                     (:as 'search-graph 'sg)
                     :where (:and (:= 'g.id 'sg.link)
                                  (:not 'cycle)))))
      (:select '* :from 'search-graph)))
#+END_SRC

* Table Functions
  :PROPERTIES:
  :ID:       dbedabf5-eaf5-4adb-b323-b42926acc81a
  :END:
** sql-op :for-update (query &key of nowait)
   :PROPERTIES:
   :ID:       ace310e6-8bd1-4211-bf66-ef56c9b7e872
   :END:

Locks the selected rows against concurrent updates. This will prevent the
rows from being modified or deleted by other transactions until the current
transaction ends. The :of keyword should be followed by one or more table
names. If provided, PostgreSQL will lock these tables instead of the ones
detected in the select statement. The :nowait keyword should be provided
by itself (with no argument attached to it), after all the :of arguments.
If :nowait is provided, PostgreSQL will throw an error if a table cannot be
locked immediately, instead of pausing until it's possible.
#+BEGIN_SRC lisp
(query (:for-update (:select :* :from 'foo 'bar 'baz) :of 'bar 'baz :nowait))
#+END_SRC

** sql-op :for-share (query &key of nowait)
   :PROPERTIES:
   :ID:       457394be-ef0d-444a-ad33-fefbc39363e3
   :END:

Similar to :for-update, except it acquires a shared lock on the table,
allowing other transactions to perform :for-share selects on the locked
tables.

** sql-op :insert-into (table &rest rest)
   :PROPERTIES:
   :ID:       a63202ff-4aa9-4af3-9b82-254516db07e1
   :END:

Insert a row into a table. When the second argument is :set, the other
arguments should be alternating field names and values, otherwise it
should be a :select form that will produce the values to be inserted.
Example:
#+BEGIN_SRC lisp
(query (:insert-into 'my-table :set 'field-1 42 'field-2 "foobar"))
#+END_SRC

It is possible to add :returning, followed by a list of field names or
expressions, at the end of the :insert-into form. This will cause the
query to return the values of these expressions as a single row.

In postgresql versions 9.5 and above, it is possible to add
:on-conflict-do-nothing (if the item already exists, do nothing),
or :on-conflict-update (if the item already exists, update the values)
followed by a list of field names which are checked for the conflict
then using :update-set followed by a list of field names or expressions
following the syntax for updating a table. This is sometimes called
an "upsert". Note that as per the postgresql sql documentation you must
prepend the table name to the column in the where statement if you are updating.
#+BEGIN_SRC lisp
(query (:insert-into 'test-table :set 'column-A '$1 'column-B '$2
                     :on-conflict-update 'column-A
                     :update-set 'column-B '$2
                     :where (:= 'test-table.column-A '$1)) "c" 37)
#+END_SRC

** sql-op :insert-rows-into (table &rest rest)
   :PROPERTIES:
   :ID:       26d60b83-60f5-4bb4-8a03-cd897a455139
   :END:

Insert multiple rows into a table. Specify the columns first with the
keyword :columns then provide a list of lists of the values as a
parameter to the keyword :values. Example:
#+BEGIN_SRC lisp
(query (:insert-rows-into 'my-table :columns 'field-1 'field-2
                                    :values '((42 "foobar") (23 "foobaz"))))
#+END_SRC

If you will use the default columns, this can be simplified and the :columns
parameters can be dropped. Example:
#+BEGIN_SRC lisp
(query (:insert-rows-into 'my-table
                          :values '((42 "foobar") (23 "foobaz"))))
#+END_SRC

** sql-op :update (table &rest rest)
   :PROPERTIES:
   :ID:       bbf790c1-9baa-4cf0-900c-16a5a2bc2081
   :END:

Update values in a table. After the table name there should follow the
keyword :set and any number of alternating field names and values, like
for :insert-into. Next comes the optional keyword :from, followed by at
least one table name and then any number of join statements, like for
:select. After the joins, an optional :where keyword followed by the condition,
and :returning keyword followed by a list of field names or expressions
indicating values to be returned as query result.

** sql-op :delete-from (table &rest rest)
   :PROPERTIES:
   :ID:       cdee608e-71cb-4d41-9e1d-a21b7728d956
   :END:

Delete rows from the named table. Can be given a :where argument followed
by a condition, and a :returning argument, followed by one or more
expressions that should be returned for every deleted row.

** sql-op :create-table (name (&rest columns) &rest options)
   :PROPERTIES:
   :ID:       4096efd3-8b88-4c50-8a02-d3f1a1b0d682
   :END:

Create a new table. The simplest example would pass two parameters,
the table name and a list of lists providing information for each column.
For example:
#+BEGIN_SRC lisp
(query (:create-table 'george ((id :type integer))))
#+END_SRC
where 'george is the name of the table, it has 1 column named id
which is limited to integers. There are no indexes or keys in this
example.

See [[file:create-tables.html]] for more detailed examples.

*** Column Definition parameters
    :PROPERTIES:
    :ID:       d0a01fab-1489-47dd-8307-30c28351e8af
    :END:
After the table name a list of column definitions
follows, which are lists that start with a name, followed by one or
more of the following keyword arguments:

- :type

This one is required. It specifies the type of the column. Use a type like
(or db-null integer) to specify a column that may have NULL values.

- :default

Provides a default value for the field.

- :unique

If this argument is non-nil, the values of the column must be unique.

- :primary-key

When non-nil, the column is a primary key of the table.

- :check

Adds a constraint to this column. The value provided for this argument must
be an S-SQL expression that returns a boolean value. It can refer to other
columns in the table if needed.

- :references

Adds a foreign key constraint to this table. The argument provided must be a
list of the form (target &optional on-delete on-update). When target is a
symbol, it names the table to whose primary key this constraint refers. When
it is a list, its first element is the table, and its second element the
column within that table that the key refers to. on-delete and on-update
can be used to specify the actions that must be taken when the row that this
key refers to is deleted or changed. Allowed values are :restrict, :set-null,

- :set-default, :cascade, and :no-action.

*** Table Constraints
    :PROPERTIES:
    :ID:       6ee6a88c-1810-41f9-8cad-2c7d347f9c4a
    :END:
After the list of columns, zero or more extra options (table constraints) can
be specified. These are lists starting with one of the following keywords:

- :check

Adds a constraint to the table. Takes a single S-SQL expression that produces
a boolean as its argument.

- :primary-key

Specifies a primary key for the table. The arguments to this option are the
names of the columns that this key consists of.

- :unique

Adds a unique constraint to a group of columns. Again, the arguments are a
list of symbols that indicate the relevant columns.

- :foreign-key

Create a foreign key. The arguments should have the form
(columns target &optional on-delete on-update), where columns is a list of
columns that are used by this key, while the rest of the arguments have
the same meaning as they have in the :references option for columns.
Every list can start with :constraint name to create a specifically named
constraint.

Note that, unlike most other operators, :create-table expects most of its
arguments to be unquoted symbols. The exception to this is the value
of :check constraints: These must be normal S-SQL expressions, which means
that any column names they contain should be quoted. When programmatically
generating table definitions, sql-compile is usually more practical than
the sql macro.

Here is an example of a :create-table form:
#+BEGIN_SRC lisp
(:create-table enemy
  ((name :type string :primary-key t)
   (age :type integer)
   (address :type (or db-null string) :references (important-addresses :cascade :cascade))
   (fatal-weakness :type text :default "None")
   (identifying-color :type (string 20) :unique t))
  (:foreign-key (identifying-color) (colors name))
  (:constraint enemy-age-check :check (:> 'age 12)))
#+END_SRC
For more detail and examples on building tables
using the s-sql approach, see [[file:create-tables.html][create-tables.html]]

** sql-op :alter-table (name action &rest args)
   :PROPERTIES:
   :ID:       936e7ced-7f31-4c94-9d39-81b11e2cd1cd
   :END:

Alters named table. Currently changing a column's data type is not supported.
The meaning of args depends on action:

- :add-column

Adds column to table. args should be a column in the same form as for :create-table.

- :drop-column

Drops a column from the table.

- :add-constraint

Adds a named constraint to the table.

- :drop-constraint

Drops constraint. First of args should name a constraint to be dropped; second,
optional argument specifies behaviour regarding objects dependent on the
constraint and it may equal :cascade or :restrict.

- :add

Adds an unnamed constraint to table. args should be a constraint in the same
form as for :create-table. (This is for backwards-compatibility, you should
use named constraints.)

- :rename

Adds the ability to rename a table.

- :rename-column

Adds the ability to rename a column of a table.

Here is an example using the table defined above:
#+BEGIN_SRC lsip
(query (alter-table enemy :drop-constraint enemy-age-check))

(query (:alter-table enemy :add-constraint enemy-age-check :check (:> 'age 21)))
#+END_SRC

** sql-op :drop-table (name)
   :PROPERTIES:
   :ID:       1f2b170f-09e2-40e6-9956-f3c44b1d2824
   :END:

Drops the named table. You may optionally pass :if-exists before the name
to suppress the error message. You can also optionally pass :cascade after
the name to indicate that it should also drop any other tables, indices,
etc which depend on that table.
#+BEGIN_SRC lisp
(query (:drop-table 'table1))
(query (:drop-table :if-exists 'table1))
(query (:drop-table :if-exists 'table1 :cascade))
(query (:drop-table (:if-exists 'table1-with-longer-name) :cascade))
#+END_SRC

** sql-op :truncate (&rest args)
   SCHEDULED: <2018-09-06 Thu>
   :PROPERTIES:
   :ID:       f17b0128-f74e-4e79-90e4-d7cc97848c46
   :END:

Truncates one or more tables, deleting all the rows. Optional keyword arguments are
allowed in the following order. Note that :continue-identity and :restart-identity
make no sense if both are included.

- :only (if not specified, the table and its descendants are truncated).
- :continue-identity (the values of sequences will not be changed. This is the default)
- :restart-identity (the values of sequences owned by the table(s) will be restarted)
- :cascade (will cascade the truncation through tables using foreign keys.)

Example calls would be:
#+BEGIN_SRC lisp
(query (:truncate 'bigtable 'fattable))

(query (:truncate 'bigtable 'fattable :only))

(query (:truncate 'bigtable 'fattable :only :continue-identity))

(query (:truncate 'bigtable 'fattable :restart-identity))

(query (:truncate 'bigtable 'fattable :only :restart-identity :cascade ))

#+END_SRC

** sql-op :create-index (name &rest args)
   :PROPERTIES:
   :ID:       c06560b4-5dfb-4657-aa1f-dc3913fa08fc
   :END:

Create an index on a table. After the name of the index the keyword :on should
follow, with the table name after it. Then the keyword :fields, followed by
one or more column names. Optionally, a :where clause with a condition can
be added at the end to make a partial index.

#+BEGIN_SRC lisp
(sql (:create-index 'gin-idx :on "historical-events" :using gin :fields 'data))

"CREATE INDEX gin_idx ON historical_events USING GIN (data)"
#+END_SRC


** sql-op :create-unique-index (name &rest args)
   :PROPERTIES:
   :ID:       b2f3a924-58c4-4c4e-9b08-603bb8f5bef3
   :END:

Works like :create-index, except that the index created is unique.

** sql-op :drop-index (name)
   :PROPERTIES:
   :ID:       e2c1e460-4d7b-449e-9b24-daa807f115b4
   :END:

Drop an index. Takes :if-exists and/or :cascade arguments like :drop-table.
#+BEGIN_SRC lisp
(query (:drop-index 'index1))
(query (:drop-index :if-exists 'index1))
(query (:drop-index :if-exists 'index1 :cascade))
#+END_SRC

** sql-op :create-sequence (name &key increment min-value max-value start cache cycle)
   :PROPERTIES:
   :ID:       6dad55a4-a0d4-4d94-923e-e34dd21417a0
   :END:

Create a sequence with the given name. The rest of the arguments control
the way the sequence selects values.

** sql-op :alter-sequence (name)
   :PROPERTIES:
   :ID:       16b308a1-ae6c-4cac-816d-1e29b28ce0b9
   :END:

Alters a sequence. See [[https://www.postgresql.org/docs/10/static/sql-altersequence.html][Postgresql documentation]] for parameters.

- :increment

Sets the amount by which each subsequent increment will be increased.

- :min-value

- :max-value

- :no-min

- :no-max

- :start

- :restart

- :cache

- :cycle

- :no-cycle

- :owned-by

- :if-exists before the name to suppress the error message.

** sql-op :drop-sequence (name)
   :PROPERTIES:
   :ID:       913c35f8-c6ba-42e3-a862-a46e313985ba
   :END:

Drop a sequence. Takes :if-exists and/or :cascade arguments like :drop-table.
#+BEGIN_SRC lisp
(query (:drop-sequence 'sequence1))
(query (:drop-sequence :if-exists 'sequence1))
(query (:drop-sequence :if-exists 'sequence1 :cascade))
#+END_SRC

** sql-op :create-view (name query)
   :PROPERTIES:
   :ID:       b5152a93-fc83-4e28-8678-2238987280ac
   :END:

Create a view from an S-SQL-style query.

** sql-op :drop-view (name)
   :PROPERTIES:
   :ID:       41ae2fb3-1d14-40a7-9cb3-eb194f90a692
   :END:

Drop a view. Takes optional :if-exists argument.

** sql-op :set-constraints (state &rest constraints)
   :PROPERTIES:
   :ID:       4e0e615b-cdb2-4576-a46d-20c25daf414a
   :END:

Configure whether deferrable constraints should be checked when a statement
is executed, or when the transaction containing that statement is completed.
The provided state must be either :immediate, indicating the former,
or :deferred, indicating the latter. The constraints must be either the
names of the constraints to be configured, or unspecified, indicating that
all deferrable constraints should be thus configured.

** sql-op :listen (channel)
   :PROPERTIES:
   :ID:       254e8288-3515-4a51-8704-ea17c35f2c9b
   :END:

Tell the server to listen for notification events on channel channel,
a string, on the current connection.

** sql-op :unlisten (channel)
   :PROPERTIES:
   :ID:       8899f2b4-8053-4e49-917f-8716c8ac916b
   :END:

Stop listening for events on channel.

** sql-op :notify (channel &optional payload)
   :PROPERTIES:
   :ID:       88d35022-2839-4ece-9688-c8517363e25a
   :END:

Signal a notification event on channel channel, a string. The optional
payload string can be used to send additional event information to the listeners.

** sql-op :create-role (role &rest args)
   :PROPERTIES:
   :ID:       e4c5a84e-3a66-4a80-91de-b673beb8376d
   :END:

Create a new role (user). Following the role name are optional keywords
arguments:

- :options

One or more of the no-parameter options to PostgreSQL's CREATE ROLE SQL command.

- :password

Sets the role's password. (A password is only of use for roles having the LOGIN
attribute, but you can nonetheless define one for roles without it.) If you do
not plan to use password authentication you can omit this option. If no
password is specified, the password will be set to null and password
authentication will always fail for that user.

- :connection-limit

If role can log in, this specifies how many concurrent connections the role can
make. -1 (the default) means no limit.

- :valid-until

The :valid-until clause sets a date and time after which the role's password
is no longer valid. If this clause is omitted the password will be valid for
all time.

- :role

Lists one or more existing roles which are automatically added as members of
the new role. (This in effect makes the new role a “group”.)

- :in-role

Lists one or more existing roles to which the new role will be immediately
added as a new member.

Here is an example of a :create-role form:
#+BEGIN_SRC lisp
(query (:create-role 'user23
                     :options 'SUPERUSER 'NOINHERIT 'LOGIN
                     :password "mypassword"
                     :connection-limit 100 :role 'users))
#+END_SRC

** sql-op :create-database (name)
   :PROPERTIES:
   :ID:       6d429954-eb91-4a94-8655-f1e1a75f02c8
   :END:

Create a new database with the given name.

** sql-op :drop-database (name)
   :PROPERTIES:
   :ID:       35ecfdd0-7ba1-45cc-a73d-68323c880c29
   :END:

Drops the named database. You may optionally pass :if-exists before the
name to suppress the error message. Examples:
#+BEGIN_SRC lisp
(query (:drop-database 'database-name))
(query (:drop-database :if-exists 'database-name))
#+END_SRC

** sql-op :copy (table &rest args)
   :PROPERTIES:
   :ID:       962e6b5e-8ce6-4083-a17e-010679d12b32
   :END:

Move data between Postgres tables and filesystem files. Table name is required
followed by one or more of the following keyword arguments. Documentation for
the copy command provides a full reference. An example from the Greenplum
tutorial:
#+BEGIN_SRC lisp
(query
   (:copy 'faa.d_airlines
    :columns 'airlineid 'airline_desc
  	:from "/home/gpadmin/gpdb-sandbox-tutorials/faa/L_AIRLINE_ID.csv"
  	:on-segment t
  	:binary t
  	:oids t
	  :header t
  	:delimiter ","
	  :null "NULL"
  	:escape "my-escape-string"
  	:newline "CR"
	  :csv t
  	:log-errors t
	  :segment-reject-limit 100 'ROWS))

#+END_SRC
* Dynamic Queries, Composition and Parameterized Queries
  :PROPERTIES:
  :CUSTOM_ID: dynamic-queries-composition-and-parameterized-queries
  :ID:       d621dc4b-5ae1-408a-be3c-c553dcd5d9a6
  :END:

** Overview
   :PROPERTIES:
   :CUSTOM_ID: overview
   :ID:       56999390-1d72-4ae1-bea6-1f3a5eeb08f7
   :END:

The question gets asked how to build dynamic or composable queries in
postmodern. First we need to understand the context - is the programmer
building the query or are you taking data from a user and using that to
build a query?

*** Programmer Built Queries
    :PROPERTIES:
    :CUSTOM_ID: programmer-built-queries
    :ID:       17b9050a-026f-4552-93b3-e08cb9ba5851
    :END:

If you are not using s-sql, then it becomes easy. The query macro
assumes that everything that is not a list starting with a keyword will
evaluate to a string. That means you can build it with a simple format
string

#+BEGIN_EXAMPLE
  (query (format nil "select ~a from ~a where ~a"  "carrots" "garden" "length > 3"))
#+END_EXAMPLE

With s-sql, there are generally two approaches to building dynamic or
composible queries: either use sql-compile or use :raw.

For purposes of this example, we will use the following employee table:

#+BEGIN_EXAMPLE
  (query (:create-table employee ((id :type int)
                                  (name :type text)
                                  (salary :type numeric)
                                  (start_date :type date)
                                  (city :type text)
                                  (region :type char)
                                  (age :type int))))

  (query (:insert-rows-into 'employee
                            :columns 'id 'name 'salary 'start-date 'city 'region 'age
                            :values '((1 "Jason" 40420 "02/01/94" "New York" "W" 29)
                                      (2 "Robert" 14420 "01/02/95" "Vancouver" "N" 21)
                                      (3 "Celia" 24020 "12/03/96" "Toronto" "W" 24)
                                      (4 "Linda" 40620 "11/04/97" "New York" "N" 28)
                                      (5 "David" 80026 "10/05/98" "Vancouver" "W" 31)
                                      (6 "James" 70060 "09/06/99" "Toronto" "N" 26)
                                      (7 "Alison" 90620 "08/07/00" "New York" "W" 38)
                                      (8 "Chris" 26020 "07/08/01" "Vancouver" "N" 22)
                                      (9 "Mary" 60020 "06/08/02" "Toronto" "W" 34))))
#+END_EXAMPLE

1. Approach #1 Use sql-compile

Sql-compile does a run-time compilation of an s-sql expression. In the
following example, we create a function that accepts a where-clause, a
table-name, 3 columns to select and two parameters to go into the where
clause.

#+BEGIN_EXAMPLE
  (defun toy-example (where-clause table-name col1 col2 col3 arg1 arg2)
         (with-test-connection
         (query (sql-compile
                  (append `(:select ,col1 ,col2 ,col3 :from ,table-name :where)
                         where-clause))
                arg1 arg2)))

      (toy-example '((:and (:= 'city '$1) (:> 'salary '$2))) 'employee 'id 'name 'city "Toronto" 45000)

      ((6 "James" "Toronto") (9 "Mary" "Toronto"))
#+END_EXAMPLE

If we just look at what this call to sql-compile in toy-example
generates, it would look like:

#+BEGIN_EXAMPLE
      "(SELECT id, name, city FROM employee WHERE ((city = $1) and (salary > $2)))"
#+END_EXAMPLE

This example is still a parameterized query but for security reasons you
will need to be very careful how you generate the where clause.

Another example with sql-compile and append, in this case updating a
table and setting two columns to NULL.

#+BEGIN_EXAMPLE
      (sql-compile (append '(:update :table1 :set)
                           (loop for a in '("col1" "col2")
                                 collect a
                                 collect :NULL)))

      "UPDATE table1 SET E'col1' = NULL, E'col2' = NULL"
#+END_EXAMPLE

Lets think about it differently. What if we know the universe of columns
we want to select, but want to conditionally select some of them.
Suppose we know our targetted table has columns:

#+BEGIN_EXAMPLE
  'id 'name 'salary 'start-date 'city 'region 'age.
#+END_EXAMPLE

We may decide we always want name, city and age, but salary and
start-date are conditional.

#+BEGIN_EXAMPLE
      (defun toy-example-2 (salaryp start-date-p)
        (sql-compile
         (remove nil `(:select 'name 'city 'age
                               ,(if salaryp 'salary nil)
                               ,(if start-date-p 'start-date nil)
                               :from 'employee))))

      (query (toy-example-2 t t))

      (("Jason" "New York" 29 40420 #<SIMPLE-DATE:DATE 01-02-1994>)
       ("Robert" "Vancouver" 21 14420 #<SIMPLE-DATE:DATE 02-01-1995>)
       ("Celia" "Toronto" 24 24020 #<SIMPLE-DATE:DATE 03-12-1996>)
       ("Linda" "New York" 28 40620 #<SIMPLE-DATE:DATE 04-11-1997>)
       ("David" "Vancouver" 31 80026 #<SIMPLE-DATE:DATE 05-10-1998>)
       ("James" "Toronto" 26 70060 #<SIMPLE-DATE:DATE 06-09-1999>)
       ("Alison" "New York" 38 90620 #<SIMPLE-DATE:DATE 07-08-2000>)
       ("Chris" "Vancouver" 22 26020 #<SIMPLE-DATE:DATE 08-07-2001>)
       ("Mary" "Toronto" 34 60020 #<SIMPLE-DATE:DATE 08-06-2002>))

      (query (toy-example-2 t nil))

      (("Jason" "New York" 29 40420) ("Robert" "Vancouver" 21 14420)
       ("Celia" "Toronto" 24 24020) ("Linda" "New York" 28 40620)
       ("David" "Vancouver" 31 80026) ("James" "Toronto" 26 70060)
       ("Alison" "New York" 38 90620) ("Chris" "Vancouver" 22 26020)
       ("Mary" "Toronto" 34 60020))
#+END_EXAMPLE

You could skip the (remove nil... portion and substitute t for nil. E.g.

#+BEGIN_EXAMPLE
      (defun toy-example-2 (salaryp start-date-p)
        (sql-compile
         `(:select 'name 'city 'age
                   ,(if salaryp 'salary t)
                   ,(if start-date-p 'start-date t)
                   :from 'employee)))
#+END_EXAMPLE

But I prefer to remove those segments completely from the query.

Following on this same thread of thought, you can define a portion of
the sql in a let clause:

#+BEGIN_EXAMPLE
      (let ((sql1 '(:= name "Jason")))
        (query (sql-compile
          `(:select 'name 'city 'age :from 'employee :where ,sql1))))

      (("Jason" "New York" 29))
#+END_EXAMPLE

An example of this would be getting more columns depending on the
postgresql server versionr:

#+BEGIN_EXAMPLE
      (defun more-table-info (table-name)
        "Returns variable amounts of information depending on the postgresql server version"
        (let* ((version>11 (postgresql-version-at-least "12.0" *database*))
               (version>10 (postgresql-version-at-least "11.0" *database*))
               (select-query (sql-compile
                              `(:order-by
                                (:select (:as 'a.attnum 'ordinal-position)
                                         (:as 'a.attname 'column-name)
                                         (:as 'tn.typname 'data-type)
                                         ,(if version>10 'a.attidentity t)
                                         ,(if version>11 'a.attgenerated t)
                                         :from (:as 'pg_class 'c)
                                         (:as 'pg_attribute 'a)
                                         (:as 'pg_type 'tn)
                                         :where (:and
                                                 (:= 'c.relname '$1)
                                                 (:> 'a.attnum 0)
                                                 (:= 'a.attrelid 'c.oid)
                                                 (:= 'a.atttypid 'tn.oid)))
                                'a.attnum))))
          (query select-query
                 (to-sql-name table-name))))
#+END_EXAMPLE

2. Approach #2 Use :raw

To quote Marijn, the :raw keyword takes a string and inserts it straight
into the query. I try to stay away from :raw if possible, but
sometimes...

#+BEGIN_EXAMPLE
      (query (:select (:raw "tmp1.name") :from (:as 'baz (:raw "tmp1"))))
#+END_EXAMPLE

*** Queries with User Input
    :PROPERTIES:
    :CUSTOM_ID: queries-with-user-input
    :ID:       db5db32e-31b5-424e-8cb8-97bb88029515
    :END:

In any of the above approaches to building queries you will need to
ensure that either you have control over the inputs or they still result
in parameterized queries. If not you have opened yourself up to an sql
injection attack.
